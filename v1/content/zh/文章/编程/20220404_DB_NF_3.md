---
title: "数据库 | 实例讲解3范式"
date: 2022-04-03T20:31:40+08:00
draft: false
分类: ["编程"]
标签: ["数据库", "范式"]
# weight: 1
cover:
    image: "https://www.lifewire.com/thmb/9_Rb1VpMfUJgyW7skIlmkjlA7Qs=/3644x2430/filters:fill(auto,1)/database-157334670-5c29939d46e0fb0001edf766-f2f4c8e9293e4eef9607abf61d6a5446.jpg"
    # can also paste direct link from external site
    # ex. https://i.ibb.co/K0HVPBd/paper-mod-profilemode.png
    alt: "Cover Image"
    # caption: ""
    relative: false # To use relative path for cover image, used in hugo Page-bundles
summary: "如何把一张表格从不合格改成符合3NF标准？"
author: "AidenCLX"
translationKey: "dbdeduce3nf"
---

## 写在前面

在以前，我的项目主要都是使用非关系型数据库构建的，比如使用firebase。这使得我能够快速开发不需要使用复杂数据库结构的产品，但同时也减少了我去深入了解关系型数据库的机会。因此，我去查阅了一些相关资料，但诚实的说，很多资料其实写的真的并不好。。他们使用复杂的语言来讲述一个简单的关系，而且常常还不带任何的例子，这带来了许多理解上的不便。

我并不是在说我们不应该使用书面语言。但事实上，有一个通俗易懂的例子总是好的，不是吗？

那么就让我们开始吧。在这篇文章里面我将会试着去讲解数据库的三大范式，并利用一个例子来说明他们。

---

## 1NF

对于第一范式，要求非常简单：

1. 不能有重复行。
2. 所有的属性和数据都是原子性的、不可分的。

看一下下面的表格：

![img](/dbnf3/nf1_before.jpg)

嗯，看起来不错，不是吗？但真的是这样吗？我们来看看：

1. 不会出现重复行，好的。。。
2. 欸！不是所有的属性都是原子性的！

看一下`name`部分。我们可以把它分成姓和名不是吗！这就造成问题了，让我们改一下：

![img](/dbnf3/nf1_after.jpg)

好多了。但这张表格看起来还是有点太复杂。我们可以在2NF和3NF的时候进一步优化。

---

## 2NF

第二范式首先要满足第一范式，此外还需要满足：

1. 没有部份依赖。

啥是部分依赖啊？不懂啊？救救孩子吧。其实部份依赖没那么玄乎，说起来就是：

1. 别在主键里面加废话。

啥意思呢？看一下我们前面的表格吧。我们可以说一个人的部门。职称和职责完全是由一个人的ID决定的，但我们的主键却包含了一个人的名字。这就是废话的部分——去掉了这部分，ID依旧决定了这些列。那么怎么改变呢？很简单，分表：

![img](/dbnf3/nf2_after.jpg)

> 我好像忘记把生日加进去了，但你明白我想说明什么。

我们可以做的更好吗？是的！

---

## 3NF

就像2NF一样，3NF首先要满足2NF。此外还需要：

1. 没有过渡性的依赖

这是啥意思呢？举个例子吧，假设主键是ID，我们可以清楚的看到一个人的部门和职称依赖于一个人的ID，但职责呢？事实上职责依赖于一个人的部门和职称。这就是过渡性的依赖了，A依赖于B，B依赖于C，C是主键。那这个时候怎么办呢？我们拆分成A和B，B和C的两张表就可以了。很简单吧？

---

## 写在3NF之后

事实上除了3NF，我们还有BCNF，4NF，5NF。不过这些范式对于大多数应用场景都过于复杂难用了，所以我也不会在这篇文章中再去赘述。