---
title: "编程 | 线程和进程"
date: 2022-04-18T13:16:00+08:00
draft: false
分类: ["编程"]
标签: ["线程", "进程"]
# weight: 1
cover:
    image: "https://i.ytimg.com/vi/Dhf-DYO1K78/maxresdefault.jpg"
    # can also paste direct link from external site
    # ex. https://i.ibb.co/K0HVPBd/paper-mod-profilemode.png
    alt: "Cover Image"
    caption: "我不拥有这张图片。此图片仅用于非商业用途。如果侵犯了您的权利，请联系我去除。"
    relative: false # To use relative path for cover image, used in hugo Page-bundles
summary: "我真的很讨厌线程这个术语，它太搞了！"
author: "AidenCLX"
translationKey: "Threads and Processes"
---

我写这篇文章的原因其实很简单。我被问到了关于进程和线程的问题。在过去，我一直以为我的认识已经足够深入，但事实证明我还有很多欠缺的地方。因此我去查阅了更多的资料，并且在这里写下这篇文章谨作知识分享。

---

## 进程

为什么从进程开始？理由其实很显然：因为进程更简单。我并不是说进程在技术上更简单，只是它更便于理解。所以说到底进程是什么呢？从本质上说，进程是一种抽象。它被用于系统层面上的用户程序之间的相互隔离，并于底层硬件也隔离。进程，正式的说，是资源分配的最小单位。你不能够在**系统层面**分配更小的资源了。

那么一个进程有些什么呢？首先他有一个独立的虚拟内存空间。这也即是我们所说的“进程不共享内存空间”的来源。如果你的系统是32位的，那么每个程序将会拥有32位的虚拟内存地址，如果是64位，则是64位的虚拟内存地址。进程与进程之间的虚拟内存空间相互独立，互不分享。一个进程同时也拥有它自己的文件描述符，PID，独享的栈，堆，文本，等等等等。进程间的切换需要很大的费用就是这么来的：你要保存当前的信息，载入其他进程的信息，切换到其他的虚拟内存地址，而且很可能会遇到缺页错误，等等。

但这并不代表进程就没有优势了。感谢进程的相互独立特性，一个进程崩溃了并不会影响到其他的进程，这代表着多进程有些时候可以提高系统的可用性。这也是为什么我们常常能看到守护进程，而不是守护线程的原因。

---

## 线程

人们总是对线程感到困惑，我也不例外。原因也很简单：线程究竟是什么？emmm，这其实要结合上下文来讨论，但一般来说人们都是在说内核线程。或者换句话说，系统线程。你可能会感到困惑，什么？线程还不止一种？嘿，还真是这样。这也是困惑的来源。

一个线程，首先，是一个比进程轻量化的东西。没人会怀疑这一点。但轻量化到什么程度呢？这就要看实现是怎么样的了。

当你的老师或者教授提到线程的时候，他们很大可能是在说内核线程，也是我们所说的所谓``POSIX线程``，如果你用c++来做多线程的话，也可以叫``pthread``。这些线程由操作系统来创建、回收，并且完全由系统调度。这意味着你对于他们没有什么控制权-你只能够给他们分配任务，然后操作系统能够帮你解决一切。这些线程需要获取资源：他们会保留属于自己的堆、栈，但他们会分享同一进程的比如文本段或者文件描述符。他们也分享虚拟内存地址。

更准确地说，一个进程内至少有一个线程。时至今日，事实上cpu调度器只是在调度内核线程，而不是进程（需要提到的是，linux中的线程其实是轻量化的进程...）。

这就是内核进程了。接下来我们说说用户进程。

一个用户线程是什么？嗯，他其实只是另一层抽象罢了。它被用于给予编程者更多的调度控制。我们能够利用用户线程实现合作调度而不是抢占调度，而抢占调度有的时候遇到阻塞IO就不够有效率。

准确的说，一个用户线程就是调度器是由编程语言来实现的线程。同时，一个用户线程可能需要也可能不需要另外在安置额外的独享资源，但这也是基于不同的实现而言的。

其他还有些术语，比如协程；这些术语非常让人迷惑，他们到底是什么呢？emmm，这是个好问题。我以前以为这些协程就是比线程还小的单元，但事实上并非如此；他们其实就是线程。准确来说，他们就是**用户线程**。

你肯定从你的教授或者老师那里听过用户线程和内核线程这几个词，以及他们的映射关系。现在你知道你们教授和老师们在指代什么了。我们用go语言来举例：go语言会根据cpu核数来初始化一个内核线程池，比如你有4个逻辑核心，则会初始化四个内核线程。当然你可以改变这个数值。在运行的时候，每个goroutine都会被映射到一个内核线程上在运行，而调度则是使用go自己实现的调度器。长话短说，内核线程和用户线程并不是互斥的，很多时候他们可以一起使用，具体表现为内核线程决定cpu时间，而用户线程决定执行的逻辑块是什么。

---

## 总结

许多的困惑都来源于线程这个术语。当说到线程的时候，我们一直都在说内核线程而不是用户线程；同时我们一直将协程看作用户线程。希望这些能够帮助你们的理解。